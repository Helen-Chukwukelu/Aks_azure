apiVersion: rabbitmq.com/v1beta1
kind: RabbitmqCluster
metadata:
  name: production-ready
spec:
  replicas: 3
  resources:
    requests:
      cpu: 1
      memory: 2Gi
    limits:
      cpu: 4
      memory: 4Gi
  rabbitmq:
    additionalConfig: |
      cluster_partition_handling = pause_minority
      vm_memory_high_watermark_paging_ratio = 0.99
      disk_free_limit.relative = 1.0
      collect_statistics_interval = 10000
  persistence:
    storageClassName: ssd
    storage: "10Gi"
  affinity:
    podAntiAffinity:
      requiredDuringSchedulingIgnoredDuringExecution:
      - labelSelector:
          matchExpressions:
            - key: app.kubernetes.io/name
              operator: In
              values:
              - production-ready
        topologyKey: kubernetes.io/hostname
  override:
    statefulSet:
      spec:
        template:
          spec:
            containers: []
            topologySpreadConstraints:
            - maxSkew: 1
              topologyKey: "topology.kubernetes.io/zone"
              whenUnsatisfiable: DoNotSchedule
              labelSelector:
                matchLabels:
                  app.kubernetes.io/name: production-ready

---

apiVersion: rabbitmq.com/v1beta1
kind: RabbitmqCluster
metadata:
  labels:
    app: rabbitmq
  annotations:
    some: annotation
  name: rabbitmqcluster-sample
spec:
  replicas: 3
  image: my-private-registry/rabbitmq:3.8 #specify this if you are pulling from private repo
  imagePullSecrets: #provide the secret to pull the image
  - name: some-secret
  service:
    type: LoadBalancer
    annotations:
      service.beta.kubernetes.io/aws-load-balancer-internal: 0.0.0.0/0
  resources:
    requests:
      cpu: 1000m
      memory: 2Gi
    limits:
      cpu: 2000m
      memory: 2Gi
  persistence:
    storageClassName: standard
    storage: "10Gi"
  affinity:
    nodeAffinity:
      requiredDuringSchedulingIgnoredDuringExecution:
        nodeSelectorTerms:
        - matchExpressions:
          - key: kubernetes.io/hostname
            operator: In
            values:
            - node-1
  tolerations:
    - key: "dedicated"
      operator: "Equal"
      value: "rabbitmq"
      effect: "NoSchedule"
  rabbitmq:
    additionalConfig: |
      cluster_partition_handling = pause_minority
      vm_memory_high_watermark_paging_ratio = 0.99
      disk_free_limit.relative = 1.0
      collect_statistics_interval = 10000
    advancedConfig: |
      [
          {ra, [
              {wal_data_dir, '/var/lib/rabbitmq/quorum-wal'}
          ]}
      ].
    envConfig: |
      RABBITMQ_DISTRIBUTION_BUFFER_SIZE=some_value
    additionalPlugins:
      - rabbitmq_top
      - rabbitmq_shovel
  tls:
    secretName: rabbitmq-server-certs
    caSecretName: rabbitmq-ca-cert
    disableNonTLSListeners: true
  skipPostDeploySteps: true
  terminationGracePeriodSeconds: 60
  override:
    statefulSet:
      spec:
        template:
          spec:
            initContainers:
            # Since k8s 1.9.4, config maps mount read-only volumes. Since the Docker image also writes to the config file,
            # the file must be mounted as read-write. We use init containers to copy from the config map read-only
            # path, to a read-write path
            - name: "rabbitmq-config"
              image: busybox:1.32.0
              volumeMounts:
              - name: rabbitmq-config
                mountPath: /tmp/rabbitmq
              - name: rabbitmq-config-rw
                mountPath: /etc/rabbitmq
              command:
              - sh
              - -c
              # the newline is needed since the Docker image entrypoint scripts appends to the config file
              - cp /tmp/rabbitmq/rabbitmq.conf /etc/rabbitmq/rabbitmq.conf && echo '' >> /etc/rabbitmq/rabbitmq.conf;
                cp /tmp/rabbitmq/enabled_plugins /etc/rabbitmq/enabled_plugins
            volumes:
            - name: rabbitmq-config
              configMap:
                name: rabbitmq-config
                optional: false
                items:
                - key: enabled_plugins
                  path: "enabled_plugins"
                - key: rabbitmq.conf
                  path: "rabbitmq.conf"
            # read-write volume into which to copy the rabbitmq.conf and enabled_plugins files
            # this is needed since the docker image writes to the rabbitmq.conf file
            # and Kubernetes Config Maps are mounted as read-only since Kubernetes 1.9.4
            - name: rabbitmq-config-rw
              emptyDir: {}
            - name: rabbitmq-data
              persistentVolumeClaim:
                claimName: rabbitmq-data
            serviceAccount: rabbitmq
            # The Docker image runs as the `rabbitmq` user with uid 999 
            # and writes to the `rabbitmq.conf` file
            # The security context is needed since the image needs
            # permission to write to this file. Without the security 
            # context, `rabbitmq.conf` is owned by root and inaccessible
            # by the `rabbitmq` user
            securityContext:
              fsGroup: 999
              runAsUser: 999
              runAsGroup: 999
            containers:
            - name: rabbitmq
              # Community Docker Image
              image: rabbitmq:latest
              volumeMounts:
              # mounting rabbitmq.conf and enabled_plugins
              # this should have writeable access, this might be a problem
              - name: rabbitmq-config-rw
                mountPath: "/etc/rabbitmq"
                # mountPath: "/etc/rabbitmq/conf.d/"
              # rabbitmq data directory
              - name: rabbitmq-data
                mountPath: "/var/lib/rabbitmq/mnesia"
              env:
              - name: RABBITMQ_DEFAULT_PASS
                valueFrom:
                  secretKeyRef:
                    name: rabbitmq-admin
                    key: pass
              - name: RABBITMQ_DEFAULT_USER
                valueFrom:
                  secretKeyRef:
                    name: rabbitmq-admin
                    key: user
              - name: RABBITMQ_ERLANG_COOKIE
                valueFrom:
                  secretKeyRef:
                    name: erlang-cookie
                    key: cookie
              ports:
              - name: amqp
                containerPort: 5672
                protocol: TCP
              - name: management
                containerPort: 15672
                protocol: TCP
              - name: prometheus
                containerPort: 15692
                protocol: TCP
              - name: epmd
                containerPort: 4369
                protocol: TCP
              livenessProbe:
                exec:
                  # This is just an example. There is no "one true health check" but rather
                  # several rabbitmq-diagnostics commands that can be combined to form increasingly comprehensive
                  # and intrusive health checks.
                  # Learn more at https://www.rabbitmq.com/monitoring.html#health-checks.
                  #
                  # Stage 2 check:
                  command: ["rabbitmq-diagnostics", "status"]
                initialDelaySeconds: 60
                # See https://www.rabbitmq.com/monitoring.html for monitoring frequency recommendations.
                periodSeconds: 60
                timeoutSeconds: 15
              readinessProbe: # probe to know when RMQ is ready to accept traffic
                exec:
                  # This is just an example. There is no "one true health check" but rather
                  # several rabbitmq-diagnostics commands that can be combined to form increasingly comprehensive
                  # and intrusive health checks.
                  # Learn more at https://www.rabbitmq.com/monitoring.html#health-checks.
                  #
                  # Stage 1 check:
                  command: ["rabbitmq-diagnostics", "ping"]
                initialDelaySeconds: 20
                periodSeconds: 60
                timeoutSeconds: 10

#reference links:
#https://github.com/rabbitmq/diy-kubernetes-examples/tree/master/gke
#https://www.rabbitmq.com/kubernetes/operator/using-operator.html
